<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#01161E" />
    <title>Home Screen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Karla:wght@400;700&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: '#01161E',
                        background: '#124559',
                        primary: '#598392',
                        secondary: '#AEC3B0',
                        light: '#EFF6E0',
                        accent: '#83c5be',
                        rest: '#94d1be',
                        interval: '#e76f51',
                        warning: '#fc814a',
                    },
                    fontFamily: {
                        karla: ['Karla', 'sans-serif'],
                    }
                },
            },
        };
    </script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            padding-top: env(safe-area-inset-top);
            background-color: #01161E;
            font-family: 'Karla', sans-serif;
            overscroll-behavior: none;
            scroll-padding-top: 4rem;
            scroll-behavior: smooth;
            color: #EFF6E0; /* Added for general text color */
        }

        header {
            position: sticky;
            top: 0;
            z-index: 50;
            padding: 1rem;
            background-color: #01161E;
            transition: background-color 0.3s ease, backdrop-filter 0.3s ease;
            display: flex; /* Ensure header items are aligned */
            justify-content: space-between;
            align-items: center;
        }

        header::before {
            content: "";
            position: absolute;
            top: -100vh;
            left: 0;
            right: 0;
            height: 100vh;
            background-color: #01161E;
            z-index: -1;
        }

        header.scrolled {
            background-color: rgba(1, 22, 30, 0.7);
            backdrop-filter: blur(6px);
        }

        .header-button {
            background: none;
            border: none;
            color: #83c5be; /* accent color */
            font-weight: 600;
            font-size: 1rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            text-decoration: none;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
            transition: color 0.2s;
        }

        .header-title {
            font-size: 1.25rem; /* adjusted from xl for consistency */
            font-weight: bold;
            color: #83c5be;
            text-align: center;
            letter-spacing: 0.025em;
            flex-grow: 1; /* Allow title to take available space */
        }

        .timer-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            scroll-behavior: smooth;
            height: calc(100vh - 4rem - env(safe-area-inset-top)); /* Adjust height for header and padding */
            padding-bottom: 1rem; /* Padding at the bottom of the list */
        }
        
        /* Hide scrollbar for webkit browsers */
        .timer-list::-webkit-scrollbar {
            display: none;
        }
        /* Hide scrollbar for Firefox */
        .timer-list {
            scrollbar-width: none;
        }

        .timer-item {
            background-color: #124559;
            border-bottom: 1px solid #EFF6E0; /* Thin border */
            display: flex;
            align-items: center;
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            margin-bottom: 0.5rem; /* Space between items */
            border-radius: 0.5rem; /* Slightly rounded corners */
        }

        .timer-item > div.absolute {
            position: absolute;
            top: 0;
            right: 0; /* Start at the right edge of the item */
            width: 100%; /* Take full width of the item */
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: space-around; /* Distribute buttons */
            background-color: #01161E; /* Dark background for options */
            transform: translateX(100%); /* Hidden by default, slides in from right */
            transition: transform 0.3s ease-in-out;
            padding: 1rem; /* Adjust padding to match timer-item */
            box-sizing: border-box; /* Include padding in width */
            z-index: 20; /* Ensure options are above timer-info */
            border-radius: 0.5rem; /* Match item border-radius */
        }

        .timer-item > div.absolute.slide-in {
            transform: translateX(0%);
        }

        .timer-item > div.absolute.slide-out {
            transform: translateX(100%);
        }

        .timer-item > div.absolute span {
            padding: 0.5rem 0.75rem; /* Padding for option text */
            flex-grow: 1; /* Allow options to grow */
            text-align: center; /* Center text within option */
            color: #EFF6E0; /* Light text color */
            font-weight: bold;
        }

        .timer-name-duration-wrapper { /* New wrapper for timer info */
            display: flex;
            flex-grow: 1;
            align-items: center;
            justify-content: space-between;
            position: relative; /* For z-index to be above options when not active */
            z-index: 30; /* Ensure this is above options when not active */
            background-color: inherit; /* Inherit background from timer-item */
            padding-right: 0.5rem; /* Add some padding to the right for swipe */
        }
        
        /* This rule was making the name/duration disappear, now we only hide it when options are active */
        .timer-item.options-active .timer-name-duration-wrapper {
             /* Hide the original content when options are active by pushing it out */
            transform: translateX(-100%); 
            transition: transform 0.3s ease;
        }

        .timer-name {
            font-size: 1.1rem;
            color: #EFF6E0; /* light color */
            margin-left: 0.5rem;
            flex-grow: 1;
            text-align: left; /* Align name to left */
        }

        .timer-duration {
            font-size: 0.9rem;
            color: #83c5be; /* accent color */
            white-space: nowrap; /* Prevent duration from wrapping */
        }

        .sortable-chosen {
            background-color: #AEC3B0 !important;
            opacity: 0.7; /* Make dragged item slightly transparent */
        }

        .sort-icon {
            margin-right: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            cursor: grab; /* Indicate draggable */
            font-size: 1.2rem; /* Make grab handle more visible */
        }

        .timer-item.sortable-mode .sort-icon {
            opacity: 1;
        }

        /* Confirmation Dialog Styles (unchanged from your original, ensuring it's here) */
        .confirmation-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .confirmation-dialog-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .confirmation-dialog {
            background-color: #124559;
            color: #EFF6E0;
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            max-width: 80%;
            min-width: 280px;
        }

        .confirmation-dialog p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
        }

        .confirmation-dialog-buttons {
            display: flex;
            justify-content: space-around;
            gap: 1rem;
        }

        .btn-cancel, .btn-confirm {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            font-size: 1rem;
            flex-grow: 1;
        }

        .btn-cancel {
            background-color: #598392; /* primary */
            color: #EFF6E0;
        }

        .btn-cancel:hover {
            background-color: #AEC3B0; /* secondary */
        }

        .btn-confirm {
            background-color: #e76f51; /* interval (warning/delete) */
            color: #EFF6E0;
        }

        .btn-confirm:hover {
            background-color: #fc814a; /* warning */
        }
    </style>
</head>

<body class="text-light">
    <header id="header" class="text-light shadow-md">
        <div class="w-full flex justify-between items-center">
            <button id="optionsButton" class="header-button">Options</button>
            <h1 class="header-title">Timer</h1>
            <button id="saveButton" class="header-button" style="display: none;">Save Order</button>
            <button id="addButton" class="header-button text-2xl leading-none hover:scale-110 transition-transform duration-150">+</button>
        </div>
    </header>

    <ul class="timer-list"></ul>

    <div class="confirmation-dialog-overlay" id="deleteConfirmationDialog">
        <div class="confirmation-dialog">
            <p>Delete Timer?</p>
            <div class="confirmation-dialog-buttons">
                <button class="btn-cancel" id="cancelDelete">Cancel</button>
                <button class="btn-confirm" id="confirmDelete">Delete</button>
            </div>
        </div>
    </div>

    <script src="../js/dataStorage.js"></script>

    <script>
        const header = document.getElementById('header');
        const timerList = document.querySelector('.timer-list');
        const addButton = document.getElementById('addButton');
        const saveButton = document.getElementById('saveButton');
        const optionsButton = document.getElementById('optionsButton'); // Corrected ID
        const deleteConfirmationDialog = document.getElementById('deleteConfirmationDialog'); // New ID
        const cancelDeleteButton = document.getElementById('cancelDelete'); // New ID
        const confirmDeleteButton = document.getElementById('confirmDelete'); // New ID

        let activeOptionsItem = null;
        let sortable = null;
        let longPressTimer = null;
        let longPressThreshold = 1000;
        let isSortableMode = false;

        // Initial loading of timers
        // We will now load them from dataStorage.js
        let timers = loadTimers(); // Now populated from localStorage

        // Helper functions from previous suggestion, moved here for direct access
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            let formatted = [];
            if (minutes > 0) {
                formatted.push(`${minutes} Min`);
            }
            if (seconds > 0 || (minutes === 0 && seconds === 0)) { // Ensure 0 seconds is shown
                formatted.push(`${seconds} Sek`);
            }
            return formatted.join(' ') || "0 Sek";
        }

        function calculateTotalTimerDuration(timer) {
            let duration = 0;
            timer.intervals.forEach(interval => {
                duration += interval.duration;
            });
            return duration * timer.repeat;
        }

        // --- Core Functions ---

        function renderTimerList() {
            timerList.innerHTML = ''; // Clear existing items
            timers = loadTimers(); // Always load current state from localStorage

            if (timers.length === 0) {
                const noTimersMessage = document.createElement('li'); // Changed to li for list
                noTimersMessage.classList.add('text-center', 'text-secondary', 'mt-8', 'text-lg', 'p-4');
                noTimersMessage.textContent = 'No timers yet. Tap "+" to create one!';
                timerList.appendChild(noTimersMessage);
                return;
            }

            timers.forEach(timer => {
                const li = document.createElement('li');
                li.classList.add('timer-item');
                li.setAttribute('data-timer-id', timer.id); // Add data-timer-id for lookup
                if (isSortableMode) {
                    li.classList.add('sortable-mode');
                }

                // Wrapper for timer name and duration, to be swiped
                const nameDurationWrapper = document.createElement('div');
                nameDurationWrapper.classList.add('timer-name-duration-wrapper');
                nameDurationWrapper.innerHTML = `
                    <span class="sort-icon">=</span>
                    <span class="timer-name">${timer.name}</span>
                    <span class="timer-duration">${formatTime(calculateTotalTimerDuration(timer))}</span>
                `;
                li.appendChild(nameDurationWrapper);

                // Swipe Options Container (your existing structure)
                const optionsElement = document.createElement('div');
                optionsElement.classList.add('bg-dark', 'w-full', 'h-full', 'flex', 'items-center', 'justify-around', 'absolute');
                optionsElement.style.padding = '1rem';

                // Dynamically create options with event listeners
                const optionsConfig = [
                    { text: 'Review', action: 'review', bgColor: '#598392' }, // primary
                    { text: 'Modify', action: 'modify', bgColor: '#83c5be' }, // accent
                    { text: 'Clone', action: 'clone', bgColor: '#AEC3B0' }, // secondary
                    { text: 'Delete', action: 'delete', bgColor: '#e76f51' } // interval
                ];

                optionsConfig.forEach(option => {
                    const optionSpan = document.createElement('span');
                    optionSpan.classList.add('text-light', 'cursor-pointer');
                    optionSpan.textContent = option.text;
                    optionSpan.style.backgroundColor = option.bgColor; // Apply background color directly or via class
                    optionSpan.style.padding = '0.5rem 0.75rem'; // Re-apply padding if needed
                    optionSpan.style.borderRadius = '0.25rem'; // Small rounded corners for buttons
                    optionSpan.style.flex = '1'; // Make them take equal space
                    optionSpan.style.margin = '0 0.25rem'; // Small margin between buttons

                    optionSpan.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent parent click events
                        closeOptions(li); // Close swipe options

                        const timerId = li.getAttribute('data-timer-id'); // Get the ID of the clicked timer
                        localStorage.setItem('selectedTimerId', timerId); // Store for target screen

                        switch (option.action) {
                            case 'review':
                                window.location.href = '../timer-review/timer-review.html';
                                break;
                            case 'modify':
                                window.location.href = '../timer-editor/timer-editor.html';
                                break;
                            case 'clone':
                                cloneTimer(timerId); // Pass ID instead of index
                                break;
                            case 'delete':
                                // showDeleteConfirmation will use timerId from data-attribute
                                showDeleteConfirmation(timerId); 
                                break;
                        }
                    });
                    optionsElement.appendChild(optionSpan);
                });

                li.appendChild(optionsElement);


                // --- Event Listeners for Swipe and Click ---
                let touchStartX = 0;
                let touchEndX = 0;
                let touchMoveX = 0;
                let isDragging = false; // To differentiate between drag and swipe/tap

                li.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) { // Only handle single touch
                        if (!isSortableMode) {
                            touchStartX = e.touches[0].screenX;
                            isDragging = false;
                            longPressTimer = setTimeout(() => {
                                enableSortableMode();
                            }, longPressThreshold);
                        }
                        // Close any active options if starting a new touch on a different item
                        if (activeOptionsItem && activeOptionsItem !== li) {
                            closeOptions(activeOptionsItem);
                        }
                    }
                }, { passive: true });

                li.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && !isSortableMode) {
                        touchMoveX = e.touches[0].screenX;
                        const deltaX = touchMoveX - touchStartX;
                        if (Math.abs(deltaX) > 10) { // Consider it a drag if moved more than 10px
                            isDragging = true;
                            clearTimeout(longPressTimer); // Cancel long press if swiping
                            
                            // Adjust the transform of the nameDurationWrapper
                            // Calculate the target X position, ensuring it doesn't go too far left
                            const optionsWidth = optionsElement.offsetWidth;
                            const targetX = Math.min(0, Math.max(-optionsWidth, deltaX));
                            nameDurationWrapper.style.transform = `translateX(${targetX}px)`;

                            // Also, if options are active and user pulls right, start closing them
                            if (li.classList.contains('options-active')) {
                                nameDurationWrapper.style.transform = `translateX(${Math.min(0, deltaX - optionsWidth)}px)`;
                            }
                        }
                    }
                }, { passive: true });

                li.addEventListener('touchend', (e) => {
                    if (e.changedTouches.length === 1) { // Only handle single touch end
                        if (!isSortableMode) {
                            touchEndX = e.changedTouches[0].screenX;
                            clearTimeout(longPressTimer);

                            const deltaX = touchEndX - touchStartX;
                            const swipeThreshold = 50; // Threshold for swipe detection

                            if (isDragging) { // Was it a drag/swipe gesture?
                                const currentTransform = parseInt(nameDurationWrapper.style.transform.replace('translateX(', '').replace('px)', '') || '0');
                                const optionsWidth = optionsElement.offsetWidth;

                                if (deltaX < -swipeThreshold || (currentTransform < -optionsWidth / 2 && deltaX < 0)) {
                                    // Swipe left to open options
                                    showOptions(li);
                                } else if (deltaX > swipeThreshold || (currentTransform > -optionsWidth / 2 && deltaX > 0)) {
                                    // Swipe right to close options
                                    closeOptions(li);
                                } else {
                                    // Snap back if not past threshold
                                    nameDurationWrapper.style.transition = 'transform 0.3s ease';
                                    if (li.classList.contains('options-active')) {
                                        nameDurationWrapper.style.transform = `translateX(-${optionsWidth}px)`;
                                    } else {
                                        nameDurationWrapper.style.transform = `translateX(0)`;
                                    }
                                }
                            } else { // It was a tap (not a drag/swipe)
                                // Only handle click if no options are active or if clicking on the active item
                                if (!activeOptionsItem || activeOptionsItem === li) {
                                    if (!li.classList.contains('options-active')) {
                                        // This is the direct click to timer-screen
                                        const timerId = li.getAttribute('data-timer-id');
                                        localStorage.setItem('selectedTimerId', timerId);
                                        window.location.href = '../timer-screen/timer-screen.html';
                                    }
                                }
                            }
                        }
                        // Reset transforms and flags after touchend
                        nameDurationWrapper.style.transition = 'transform 0.3s ease';
                        touchStartX = 0;
                        touchEndX = 0;
                        isDragging = false;
                    }
                });


                li.addEventListener('selectstart', function(e) {
                    e.preventDefault(); // Prevent text selection on long press/drag
                });

                timerList.appendChild(li);
            });

            if (isSortableMode) {
                enableSortable();
            }
        }

        // --- Swipe Option Handling Functions ---
        function handleSwipe(listItem, endX, startX) {
            // This function is now superseded by the direct touchmove/touchend logic
            // but kept for reference if needed. The new logic directly manipulates transform
            // and then snaps in touchend.
        }

        function showOptions(listItem) {
            if (activeOptionsItem && activeOptionsItem !== listItem) {
                closeOptions(activeOptionsItem);
            }
            activeOptionsItem = listItem;

            const nameDurationWrapper = listItem.querySelector('.timer-name-duration-wrapper');
            const optionsElement = listItem.querySelector('.bg-dark.absolute');
            const optionsWidth = optionsElement.offsetWidth; // Get the actual width of the options menu

            // Slide the content to the left to reveal options
            nameDurationWrapper.style.transition = 'transform 0.3s ease';
            nameDurationWrapper.style.transform = `translateX(-${optionsWidth}px)`;

            // Make options visible (they are already positioned correctly relative to item)
            optionsElement.classList.add('slide-in');
            optionsElement.classList.remove('slide-out');
            listItem.classList.add('options-active');
        }

        function closeOptions(listItem) {
            const nameDurationWrapper = listItem.querySelector('.timer-name-duration-wrapper');
            const optionsElement = listItem.querySelector('.bg-dark.absolute');

            if (optionsElement) {
                nameDurationWrapper.style.transition = 'transform 0.3s ease';
                nameDurationWrapper.style.transform = `translateX(0)`; // Slide content back

                optionsElement.classList.add('slide-out');
                optionsElement.classList.remove('slide-in');
                
                listItem.classList.remove('options-active');
                activeOptionsItem = null;
            }
        }
        
        // Universal click listener to close options when clicking outside
        document.addEventListener('click', (event) => {
            if (activeOptionsItem) {
                const optionsElement = activeOptionsItem.querySelector('.bg-dark.absolute');
                // Check if the click is outside the active item and outside the confirmation dialog
                if (!activeOptionsItem.contains(event.target) && !deleteConfirmationDialog.contains(event.target)) {
                    closeOptions(activeOptionsItem);
                }
            }
        });


        // --- Timer-Verwaltungsfunktionen ---
        function cloneTimer(idToClone) {
            const currentTimers = loadTimers();
            const timerToClone = currentTimers.find(timer => timer.id === idToClone);

            if (timerToClone) {
                // Create a deep copy and assign a new unique ID
                const clonedTimer = JSON.parse(JSON.stringify(timerToClone));
                clonedTimer.id = `timer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; // New unique ID
                clonedTimer.name = `${clonedTimer.name} (Copy)`; // Add (Copy) to the name

                // Add to the list and save
                currentTimers.push(clonedTimer); // Or insert after original: currentTimers.splice(index + 1, 0, clonedTimer);
                saveTimers(currentTimers);
                renderTimerList(); // Re-render the list
            }
        }

        // --- Confirmation Dialog and Delete Logic ---
        let timerToDeleteId = null;

        function showDeleteConfirmation(timerId) {
            timerToDeleteId = timerId;
            deleteConfirmationDialog.classList.add('active');
        }

        function hideDeleteConfirmation() {
            deleteConfirmationDialog.classList.remove('active');
            timerToDeleteId = null;
            if (activeOptionsItem) { // Close options if they were open for the deleted item
                closeOptions(activeOptionsItem);
            }
        }

        cancelDeleteButton.addEventListener('click', hideDeleteConfirmation);
        confirmDeleteButton.addEventListener('click', () => {
            if (timerToDeleteId) {
                deleteTimer(timerToDeleteId);
                hideDeleteConfirmation();
            }
        });

        function deleteTimer(id) {
            let currentTimers = loadTimers();
            currentTimers = currentTimers.filter(timer => timer.id !== id);
            saveTimers(currentTimers);
            renderTimerList();
        }

        // --- SortableJS Functions ---
        function enableSortableMode() {
            isSortableMode = true;
            addButton.style.display = 'none';
            saveButton.style.display = 'block';
            timerList.classList.add('sortable-mode'); // Add class to list container if needed for global styling
            renderTimerList(); // Re-render to show sort icons
            enableSortable();
        }

        function disableSortableMode() {
            isSortableMode = false;
            addButton.style.display = 'block';
            saveButton.style.display = 'none';
            timerList.classList.remove('sortable-mode');
            if (sortable) {
                sortable.option("disabled", true);
                sortable.destroy(); // Destroy to clean up listeners
                sortable = null;
            }
            // Update the order in the timers array based on new DOM order
            const newOrderTimers = Array.from(timerList.children).map(li => {
                const timerId = li.getAttribute('data-timer-id');
                return timers.find(t => t.id === timerId);
            });
            timers = newOrderTimers.filter(Boolean); // Filter out any nulls if element not found
            saveTimers(timers); // Save the new order
            renderTimerList(); // Re-render to remove sort icons and update list
        }

        function enableSortable() {
            if (!sortable) {
                sortable = new Sortable(timerList, {
                    animation: 150,
                    handle: '.sort-icon', // Only drag by the icon
                    onEnd: function (evt) {
                        // Update the internal timers array after drag & drop
                        const movedItem = timers.splice(evt.oldIndex, 1)[0];
                        timers.splice(evt.newIndex, 0, movedItem);
                        // No need to save here, will be saved on disableSortableMode
                        // renderTimerList() is also not needed here, SortableJS updates DOM
                    }
                });
            } else {
                sortable.option("disabled", false);
            }
        }

        // --- Header Button Event Listeners ---
        optionsButton.addEventListener('click', () => {
            window.location.href = '../options-screen/options-screen.html';
        });

        addButton.addEventListener('click', () => {
            localStorage.removeItem('selectedTimerId'); // Ensure no old ID for new timer
            window.location.href = '../timer-editor/timer-editor.html';
        });

        saveButton.addEventListener('click', disableSortableMode);

        // --- Scroll Header Effect ---
        window.addEventListener('scroll', () => {
            if (window.scrollY > 0) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });

        // Initial render when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            renderTimerList();
        });
    </script>
</body>
</html>