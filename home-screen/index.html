<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#01161E" />
    <title>Home Screen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Karla:wght@400;700&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: '#01161E',
                        background: '#124559',
                        primary: '#598392',
                        secondary: '#AEC3B0',
                        light: '#EFF6E0',
                        accent: '#83c5be',
                        rest: '#94d1be',
                        interval: '#e76f51',
                        warning: '#fc814a',
                    },
                    fontFamily: {
                        karla: ['Karla', 'sans-serif'],
                    }
                },
            },
        };
    </script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            /* No padding-top for safe-area-inset here, let header handle it */
            background-color: #01161E;
            font-family: 'Karla', sans-serif;
            overscroll-behavior: none;
            scroll-padding-top: 4rem; /* For smooth scrolling to anchors, if any */
            scroll-behavior: smooth;
            color: #EFF6E0;
            display: flex; /* Use flex to make body fill viewport and manage content */
            flex-direction: column; /* Stack header and main content vertically */
            -webkit-font-smoothing: antialiased; /* Better font rendering */
            -moz-osx-font-smoothing: grayscale;
        }

        header {
            position: sticky;
            top: 0;
            z-index: 50;
            padding: 1rem;
            padding-top: calc(1rem + env(safe-area-inset-top)); /* Add safe area to header padding */
            background-color: #01161E;
            transition: background-color 0.3s ease, backdrop-filter 0.3s ease;
            flex-shrink: 0; /* Prevent header from shrinking */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header::before {
            content: "";
            position: absolute;
            top: -100vh; /* Cover area above header */
            left: 0;
            right: 0;
            height: 100vh;
            background-color: #01161E;
            z-index: -1;
        }

        header.scrolled {
            background-color: rgba(1, 22, 30, 0.7);
            backdrop-filter: blur(6px);
        }

        .header-button {
            background: none;
            border: none;
            color: #83c5be;
            font-weight: 600;
            font-size: 1rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            text-decoration: none;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
            transition: color 0.2s;
        }

        .header-title {
            font-size: 1.25rem;
            font-weight: bold;
            color: #83c5be;
            text-align: center;
            letter-spacing: 0.025em;
            flex-grow: 1;
        }

        .main-content { /* New wrapper for the list to take remaining height */
            flex-grow: 1; /* Allow main content to take all available space */
            overflow-y: auto; /* This allows the main content to scroll */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding: 1rem; /* Add some padding around the list */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        .main-content::-webkit-scrollbar { /* Chrome, Safari, Opera */
            display: none;
        }

        .timer-list {
            list-style: none;
            padding: 0;
            margin: 0;
            /* Removed overflow-y and height from here, main-content handles it */
        }

        .timer-item {
            background-color: #124559;
            border-bottom: 1px solid #EFF6E0;
            display: flex;
            align-items: center;
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative; /* For swipe options positioning */
            overflow: hidden; /* To hide overflowing swipe options */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            margin-bottom: 0.5rem; /* Space between items */
            border-radius: 0.5rem; /* Rounded corners for items */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
        }

        /* Original structure for timer-info (name and duration) */
        .timer-item .timer-info-wrapper {
            flex-grow: 1; /* Allow name and duration to take space */
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative; /* Essential for its transform property in swipe */
            z-index: 10; /* Ensure it's above swipe options when not swiped */
            background-color: inherit; /* To cover the swipe options when not swiped */
            transition: transform 0.3s ease-in-out; /* Smooth transition for swipe */
        }

        /* Your original swipe options container, adjusted */
        .timer-item .swipe-options-container {
            position: absolute;
            top: 0;
            right: 0; /* Start at the right edge */
            height: 100%;
            display: flex;
            align-items: center;
            /* We will control its visibility by adjusting the translateX of timer-info-wrapper */
            /* It is always on the right, and timer-info-wrapper moves over it */
            z-index: 5; /* Behind the timer-info-wrapper */
            /* Added padding to match timer-item's padding */
            padding: 1rem;
            box-sizing: border-box; /* Include padding in dimensions */
            background-color: #01161E; /* Background for options */
            border-radius: 0.5rem; /* Match timer-item radius */
        }

        /* Styles for individual swipe buttons (your original style) */
        .timer-item .swipe-options-container span {
            padding: 0.5rem 0.75rem; /* Your original padding */
            margin: 0 0.25rem; /* Small margin between buttons */
            cursor: pointer;
            font-weight: bold;
            white-space: nowrap; /* Prevent text wrapping */
            border-radius: 0.25rem; /* Small radius for buttons */
            color: #EFF6E0; /* Light text color for buttons */
        }

        /* Specific background colors for each option, as per your palette */
        .timer-item .swipe-options-container span.review-btn { background-color: #598392; } /* primary */
        .timer-item .swipe-options-container span.modify-btn { background-color: #83c5be; } /* accent */
        .timer-item .swipe-options-container span.clone-btn { background-color: #AEC3B0; } /* secondary */
        .timer-item .swipe-options-container span.delete-btn { background-color: #e76f51; } /* interval */


        /* No need for slide-in/slide-out classes on optionsElement itself,
           we control the transform of timer-info-wrapper */
        /* .timer-item.options-active state to push timer-info-wrapper left */
        .timer-item.options-active .timer-info-wrapper {
            /* This will be set by JS based on actual options width */
            /* For now, just a placeholder to indicate the state */
            transform: translateX(-100%); /* Placeholder */
        }

        .timer-name {
            font-size: 1.1rem;
            color: #EFF6E0;
            margin-left: 0.5rem;
            flex-grow: 1;
        }

        .timer-duration {
            font-size: 0.9rem;
            color: #83c5be;
        }

        .sortable-chosen {
            background-color: #AEC3B0 !important;
            opacity: 0.7;
        }

        .sort-icon {
            margin-right: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            cursor: grab;
            font-size: 1.2rem;
        }

        .timer-item.sortable-mode .sort-icon {
            opacity: 1;
        }
        
        /* Confirmation Dialog Styles (Your original, kept as is) */
        .confirmation-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .confirmation-dialog-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .confirmation-dialog {
            background-color: #124559;
            color: #EFF6E0;
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            max-width: 80%;
            min-width: 280px;
        }

        .confirmation-dialog p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
        }

        .confirmation-dialog-buttons {
            display: flex;
            justify-content: space-around;
            gap: 1rem;
        }

        .btn-cancel, .btn-confirm {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            font-size: 1rem;
            flex-grow: 1;
        }

        .btn-cancel {
            background-color: #598392;
            color: #EFF6E0;
        }

        .btn-cancel:hover {
            background-color: #AEC3B0;
        }

        .btn-confirm {
            background-color: #e76f51;
            color: #EFF6E0;
        }

        .btn-confirm:hover {
            background-color: #fc814a;
        }
    </style>
</head>

<body class="text-light">
    <header id="header" class="text-light shadow-md">
        <div class="w-full flex justify-between items-center">
            <button id="optionsButton" class="header-button">Options</button>
            <h1 class="header-title">Timer</h1>
            <button id="saveButton" class="header-button" style="display: none;">Save Order</button>
            <button id="addButton" class="header-button text-2xl leading-none hover:scale-110 transition-transform duration-150">+</button>
        </div>
    </header>

    <main class="main-content"> <ul class="timer-list"></ul>
    </main>

<<<<<<< HEAD
    <div class="confirmation-dialog-overlay" id="deleteConfirmationDialog">
        <div class="confirmation-dialog">
            <p>Delete Timer?</p>
            <div class="confirmation-dialog-buttons">
                <button class="btn-cancel" id="cancelDelete">Cancel</button>
                <button class="btn-confirm" id="confirmDelete">Delete</button>
            </div>
        </div>
    </div>

    <script src="../js/dataStorage.js"></script>

=======
>>>>>>> parent of 0ba3099 (datastorage js in Home Screen implementiert)
    <script>
        const header = document.getElementById('header');
        const timerList = document.querySelector('.timer-list');
        const addButton = document.getElementById('addButton');
        const saveButton = document.getElementById('saveButton');
        const optionsButton = document.getElementById('optionsButton');
        const deleteConfirmationDialog = document.getElementById('deleteConfirmationDialog');
        const cancelDeleteButton = document.getElementById('cancelDelete');
        const confirmDeleteButton = document.getElementById('confirmDelete');

        let activeOptionsItem = null;
        let sortable = null;
        let longPressTimer = null;
        let longPressThreshold = 1000;
        let isSortableMode = false;
        let isSwiping = false; // Flag to distinguish swipe from tap
        let touchStartX = 0;
        let touchStartY = 0; // Added for vertical movement check in long press
        let deltaXThreshold = 10; // Minimum horizontal movement for swipe
        let deltaYThreshold = 10; // Minimum vertical movement to cancel long press/tap

        let timers = loadTimers(); // Load initial timers from dataStorage.js

        // Helper function: Format time to MM:SS
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Helper function: Calculate total duration of a timer
        function calculateTotalTimerDuration(timer) {
            let duration = 0;
            timer.intervals.forEach(interval => {
                duration += interval.duration;
            });
            return duration * timer.repeat;
        }

        // --- Core Functions ---

        function renderTimerList() {
            timerList.innerHTML = '';
            timers = loadTimers(); // Always load current state from localStorage

            if (timers.length === 0) {
                const noTimersMessage = document.createElement('li');
                noTimersMessage.classList.add('text-center', 'text-secondary', 'mt-8', 'text-lg', 'p-4');
                noTimersMessage.textContent = 'No timers yet. Tap "+" to create one!';
                timerList.appendChild(noTimersMessage);
                return;
            }

            timers.forEach(timer => {
                const li = document.createElement('li');
                li.classList.add('timer-item');
                li.setAttribute('data-timer-id', timer.id);
                if (isSortableMode) {
                    li.classList.add('sortable-mode');
                }

                // Inner wrapper for timer name and duration that moves when swiping
                const timerInfoWrapper = document.createElement('div');
                timerInfoWrapper.classList.add('timer-info-wrapper');
                timerInfoWrapper.innerHTML = `
                    <span class="sort-icon">=</span>
                    <span class="timer-name">${timer.name}</span>
                    <span class="timer-duration">${formatTime(calculateTotalTimerDuration(timer))}</span>
                `;
                li.appendChild(timerInfoWrapper);

                // Swipe Options Container (your existing structure)
                const swipeOptionsContainer = document.createElement('div');
                swipeOptionsContainer.classList.add('swipe-options-container');

                const optionsConfig = [
                    { text: 'Review', action: 'review', className: 'review-btn' },
                    { text: 'Modify', action: 'modify', className: 'modify-btn' },
                    { text: 'Clone', action: 'clone', className: 'clone-btn' },
                    { text: 'Delete', action: 'delete', className: 'delete-btn' }
                ];

                optionsConfig.forEach(option => {
                    const optionSpan = document.createElement('span');
                    optionSpan.classList.add(option.className); // Add specific class for styling
                    optionSpan.textContent = option.text;

                    optionSpan.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent li click
                        closeOptions(li); // Close swipe options

                        const timerId = li.getAttribute('data-timer-id');
                        localStorage.setItem('selectedTimerId', timerId);

                        switch (option.action) {
                            case 'review':
                                window.location.href = '../home-screen/timer-review/timer-review.html'; // Corrected path
                                break;
                            case 'modify':
                                window.location.href = '../timer-editor/timer-editor.html';
                                break;
                            case 'clone':
                                cloneTimer(timerId);
                                break;
                            case 'delete':
                                showDeleteConfirmation(timerId);
                                break;
                        }
                    });
                    swipeOptionsContainer.appendChild(optionSpan);
                });

                li.appendChild(swipeOptionsContainer);

                // --- Touch Event Listeners for Swipe and Long Press ---
                li.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        touchStartX = e.touches[0].screenX;
                        touchStartY = e.touches[0].screenY;
                        isSwiping = false; // Reset swipe flag
                        
                        // Close any active options if starting a new touch on a different item
                        if (activeOptionsItem && activeOptionsItem !== li) {
                            closeOptions(activeOptionsItem);
                        }

                        if (!isSortableMode) {
                            // Start long press timer if not in sortable mode
                            longPressTimer = setTimeout(() => {
                                // Only activate sortable mode if not already swiping/dragging too much
                                if (!isSwiping) {
                                     // Prevent click from firing after long press
                                    e.preventDefault(); 
                                    enableSortableMode();
                                }
                            }, longPressThreshold);
                        }
                    }
                }, { passive: false }); // Passive: false to allow preventDefault

                li.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && !isSortableMode) {
                        const currentX = e.touches[0].screenX;
                        const currentY = e.touches[0].screenY;
                        const deltaX = currentX - touchStartX;
                        const deltaY = currentY - touchStartY;

                        // Check for significant horizontal movement (swipe)
                        if (Math.abs(deltaX) > deltaXThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                            isSwiping = true;
                            clearTimeout(longPressTimer); // Cancel long press if swiping
                            e.preventDefault(); // Prevent default scroll/bounce
                            
                            const optionsWidth = swipeOptionsContainer.offsetWidth; // Get the dynamic width of the options
                            const targetX = Math.min(0, Math.max(-optionsWidth, deltaX)); // Limit swipe
                            timerInfoWrapper.style.transform = `translateX(${targetX}px)`;

                            // Ensure options are visible if swiped open
                            li.classList.add('options-active'); // To apply styling if needed
                        } 
                        // Check for significant vertical movement (scrolling)
                        else if (Math.abs(deltaY) > deltaYThreshold) {
                            clearTimeout(longPressTimer); // Cancel long press if scrolling
                            // Allow default scroll behavior
                        }
                    }
                }, { passive: false }); // Passive: false to allow preventDefault

                li.addEventListener('touchend', (e) => {
                    if (e.changedTouches.length === 1) {
                        clearTimeout(longPressTimer); // Clear any pending long press

                        if (!isSortableMode) {
                            const currentX = e.changedTouches[0].screenX;
                            const deltaX = currentX - touchStartX;
                            const optionsWidth = swipeOptionsContainer.offsetWidth;

                            if (isSwiping) { // It was a swipe gesture
                                // Determine if options should stay open or close
                                if (deltaX < -optionsWidth * 0.4) { // Swiped far enough left to open
                                    showOptions(li);
                                } else if (deltaX > optionsWidth * 0.4 || li.classList.contains('options-active') && deltaX > 0) {
                                    // Swiped far enough right or was open and swiped right to close
                                    closeOptions(li);
                                } else {
                                    // Snap back to original position (or open if was open and not closed enough)
                                    if (li.classList.contains('options-active')) {
                                        showOptions(li); // Keep open
                                    } else {
                                        closeOptions(li); // Snap closed
                                    }
                                }
                                // Reset transform after determining final state
                                timerInfoWrapper.style.transition = 'transform 0.3s ease-in-out';
                            } else { // It was a tap or very small drag
                                // If no significant swipe happened, treat as a click to go to timer-screen
                                // But only if no options are currently active for THIS item
                                if (!li.classList.contains('options-active')) {
                                    const timerId = li.getAttribute('data-timer-id');
                                    localStorage.setItem('selectedTimerId', timerId);
                                    window.location.href = '../timer-screen/timer-screen.html';
                                }
                            }
                        }
                        isSwiping = false; // Reset flag
                    }
                });
                
                // Prevent text selection on long press/drag (your original code)
                li.addEventListener('selectstart', function(e) {
                    e.preventDefault();
                });

                timerList.appendChild(li);
            });

            // Re-enable SortableJS if in sortable mode
            if (isSortableMode) {
                enableSortable();
            }
        }

        // --- Swipe Option Handling Functions ---
        function showOptions(listItem) {
            if (activeOptionsItem && activeOptionsItem !== listItem) {
                closeOptions(activeOptionsItem);
            }
            activeOptionsItem = listItem;

            const timerInfoWrapper = listItem.querySelector('.timer-info-wrapper');
            const swipeOptionsContainer = listItem.querySelector('.swipe-options-container');
            
            // Wait for next render cycle to get correct offsetWidth
            requestAnimationFrame(() => {
                const optionsWidth = swipeOptionsContainer.offsetWidth;
                timerInfoWrapper.style.transform = `translateX(-${optionsWidth}px)`;
                listItem.classList.add('options-active');
            });
        }

        function closeOptions(listItem) {
            const timerInfoWrapper = listItem.querySelector('.timer-info-wrapper');
            // Reset transform to original position
            timerInfoWrapper.style.transform = `translateX(0px)`;
            listItem.classList.remove('options-active');
            activeOptionsItem = null;
        }
        
        // Universal click listener to close options when clicking outside
        document.addEventListener('click', (event) => {
            if (activeOptionsItem) {
                const optionsContainer = activeOptionsItem.querySelector('.swipe-options-container');
                const timerInfoWrapper = activeOptionsItem.querySelector('.timer-info-wrapper');
                // Check if the click is outside the active item AND not inside the confirmation dialog
                if (!activeOptionsItem.contains(event.target) && !deleteConfirmationDialog.contains(event.target)) {
                    closeOptions(activeOptionsItem);
                }
            }
        });


        // --- Timer-Verwaltungsfunktionen ---
        function cloneTimer(idToClone) {
            const currentTimers = loadTimers();
            const timerToClone = currentTimers.find(timer => timer.id === idToClone);

            if (timerToClone) {
                const clonedTimer = JSON.parse(JSON.stringify(timerToClone));
                clonedTimer.id = `timer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                clonedTimer.name = `${clonedTimer.name} (Copy)`;

                // Find index to insert cloned timer right after the original
                const originalIndex = currentTimers.findIndex(timer => timer.id === idToClone);
                if (originalIndex !== -1) {
                    currentTimers.splice(originalIndex + 1, 0, clonedTimer);
                } else {
                    currentTimers.push(clonedTimer); // Fallback if original not found (shouldn't happen)
                }
                
                saveTimers(currentTimers);
                timers = currentTimers; // Update local array immediately
                renderTimerList();
            }
        }

        // --- Confirmation Dialog and Delete Logic (Your original, integrated) ---
        let timerToDeleteId = null;

        function showDeleteConfirmation(timerId) {
            timerToDeleteId = timerId;
            deleteConfirmationDialog.classList.add('active');
        }

        function hideDeleteConfirmation() {
            deleteConfirmationDialog.classList.remove('active');
            timerToDeleteId = null;
            if (activeOptionsItem) {
                closeOptions(activeOptionsItem); // Ensure options are closed
            }
        }

        cancelDeleteButton.addEventListener('click', hideDeleteConfirmation);
        confirmDeleteButton.addEventListener('click', () => {
            if (timerToDeleteId) {
                deleteTimer(timerToDeleteId);
                hideDeleteConfirmation();
            }
        });

        function deleteTimer(id) {
            let currentTimers = loadTimers();
            currentTimers = currentTimers.filter(timer => timer.id !== id);
            saveTimers(currentTimers);
            timers = currentTimers; // Update local array immediately
            renderTimerList();
        }

        // --- SortableJS Functions ---
        function enableSortableMode() {
            isSortableMode = true;
            addButton.style.display = 'none';
            saveButton.style.display = 'block';
            timerList.classList.add('sortable-mode');
            renderTimerList(); // Re-render to show sort icons and apply sortable-mode class
            enableSortable();
        }

        function disableSortableMode() {
            isSortableMode = false;
            addButton.style.display = 'block';
            saveButton.style.display = 'none';
            timerList.classList.remove('sortable-mode');
            if (sortable) {
                sortable.option("disabled", true);
                sortable.destroy(); // Destroy to clean up listeners
                sortable = null;
            }
            // Update the order in the timers array based on new DOM order
            const newOrderTimers = Array.from(timerList.children)
                .map(li => {
                    const timerId = li.getAttribute('data-timer-id');
                    // Find the original timer object from our 'timers' array
                    return timers.find(t => t.id === timerId);
                })
                .filter(Boolean); // Filter out any undefined/null entries
            
            timers = newOrderTimers; // Update the global timers array
            saveTimers(timers); // Save the new order to localStorage
            renderTimerList(); // Re-render to remove sort icons and update list from saved data
        }

        function enableSortable() {
            if (!sortable) {
                sortable = new Sortable(timerList, {
                    animation: 150,
                    handle: '.sort-icon', // Only drag by the icon
                    filter: '.swipe-options-container', // Prevents dragging when clicking on swipe options
                    preventOnFilter: false, // Allows click events on filtered elements
                    onEnd: function (evt) {
                        // Update the internal timers array after drag & drop
                        // SortableJS provides oldIndex and newIndex
                        const movedItem = timers.splice(evt.oldIndex, 1)[0];
                        timers.splice(evt.newIndex, 0, movedItem);
                        // No need to save here, will be saved on disableSortableMode
                        // renderTimerList() is also not needed here, SortableJS updates DOM
                    }
                });
            } else {
                sortable.option("disabled", false);
            }
        }

        // --- Header Scroll Effect ---
        window.addEventListener('scroll', () => {
            if (window.scrollY > 0) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });

        // Initial render when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            renderTimerList();
        });
    </script>
</body>
</html>