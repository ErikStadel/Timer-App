<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mein Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="../../js/dataStorage.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: '#01161E',
                        background: '#124559',
                        primary: '#598392',
                        secondary: '#AEC3B0',
                        light: '#EFF6E0',
                        accent: '#83c5be',
                        rest: '#629471',
                        interval: '#fd5c34',
                        warning: '#fc814a',
                    },
                    fontFamily: {
                        karla: ['Karla', 'sans-serif'],
                    },
                },
            },
        };
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Karla:wght@400;700&display=swap" rel="stylesheet" />
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #01161E;
            font-family: 'Karla', sans-serif;
            overscroll-behavior: none;
        }
        .timer-card {
            background-color: #124559;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #124559;
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
        }
    </style>
</head>
<body class="text-light">
    <div class="p-4">
        <h1 class="text-xl font-bold text-accent mb-4">Mein Timer</h1>

        <div class="timer-card" id="current-interval">
            <span id="interval-name">START</span>
            <span id="interval-time">00:00</span>
            <span id="total-time">Gesamt: 00:00</span>
        </div>

        <div class="timer-card" id="next-interval">
            <span id="next-interval-name">00</span>
            <span id="next-interval-time">Gesamt: 00:00</span>
        </div>

        <button id="start-stop-button" class="bg-accent text-dark font-semibold py-2 px-4 rounded-lg mt-4 w-full">Start</button>
    </div>

    <div id="end-modal" class="modal">
        <div class="modal-content">
            <p class="text-light mb-4">Timer beenden?</p>
            <div class="flex justify-center gap-4">
                <button id="cancel-end-button" class="bg-secondary text-dark font-semibold py-2 px-4 rounded-lg">Cancel</button>
                <button id="confirm-end-button" class="bg-warning text-dark font-semibold py-2 px-4 rounded-lg">Beenden</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const timerId = urlParams.get('timerId');
            if (!timerId) {
                window.location.href = '../index.html';
                return;
            }

            const timers = loadTimers();
            const timer = timers.find(t => t.id === timerId);
            if (!timer) {
                window.location.href = '../index.html';
                return;
            }

            let isRunning = false;
            let currentIntervalIndex = 0;
            let currentRepeat = 1;
            let currentTime = 0;
            let isRest = false;
            let intervalId = null;

            const signals = loadSignals();
            const globalSignals = loadGlobalSignals();

            // Initialisiere AudioContext
            window.audioContext = window.audioContext || new (window.AudioContext || window.webkitAudioContext)();
            window.mainGainNode = window.mainGainNode || window.audioContext.createGain();
            window.mainGainNode.connect(window.audioContext.destination);

            const volumeBoost = Number(loadVolumeBoost()) || 100;
            const gainValue = 0.5 + (volumeBoost - 50) / 125;
            window.mainGainNode.gain.value = Math.max(0, gainValue);

            const startStopButton = document.getElementById('start-stop-button');
            const intervalName = document.getElementById('interval-name');
            const intervalTime = document.getElementById('interval-time');
            const totalTime = document.getElementById('total-time');
            const nextIntervalName = document.getElementById('next-interval-name');
            const nextIntervalTime = document.getElementById('next-interval-time');
            const endModal = document.getElementById('end-modal');
            const cancelEndButton = document.getElementById('cancel-end-button');
            const confirmEndButton = document.getElementById('confirm-end-button');

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            }

            function playSignal(signalId) {
                if (!signalId) return;
                const signal = signals.find(s => s.id === signalId);
                if (!signal || !signal.filePath) return;

                const audio = new Audio(`../../${signal.filePath}`);
                try {
                    const source = window.audioContext.createMediaElementSource(audio);
                    source.connect(window.mainGainNode);
                    audio.play().catch(e => console.error('Fehler beim Abspielen:', e));
                } catch (e) {
                    console.error('Fehler bei createMediaElementSource:', e);
                    audio.volume = Math.min(1.0, volumeBoost / 100);
                    audio.play().catch(e => console.error('Fallback-Fehler:', e));
                }
            }

            function calculateTotalTime() {
                let total = 0;
                timer.intervals.forEach(interval => {
                    total += (interval.durationInterval + interval.durationRest) * timer.repeat;
                });
                return total;
            }

            function updateDisplay() {
                const interval = timer.intervals[currentIntervalIndex];
                intervalName.textContent = isRest ? `Rest (${interval.name})` : interval.name;
                intervalTime.textContent = formatTime(currentTime);
                totalTime.textContent = `Gesamt: ${formatTime(calculateTotalTime())}`;

                const nextIndex = currentIntervalIndex + 1 < timer.intervals.length ? currentIntervalIndex + 1 : 0;
                const nextInterval = timer.intervals[nextIndex];
                nextIntervalName.textContent = nextInterval ? nextInterval.name : 'End';
                nextIntervalTime.textContent = nextInterval ? `Gesamt: ${formatTime(nextInterval.durationInterval)}` : 'Gesamt: 00:00';
            }

            function isLastInterval() {
                return (
                    currentIntervalIndex === timer.intervals.length - 1 &&
                    currentRepeat === timer.repeat &&
                    (isRest || timer.intervals[currentIntervalIndex].durationRest === 0)
                );
            }

            function tick() {
                currentTime--;
                if (currentTime <= 0) {
                    if (isRest || timer.intervals[currentIntervalIndex].durationRest === 0) {
                        if (isLastInterval()) {
                            playSignal(globalSignals.lastRound);
                            clearInterval(intervalId);
                            isRunning = false;
                            startStopButton.textContent = 'Start';
                            endModal.style.display = 'flex';
                            return;
                        }
                        currentIntervalIndex++;
                        if (currentIntervalIndex >= timer.intervals.length) {
                            currentIntervalIndex = 0;
                            currentRepeat++;
                            if (currentRepeat > timer.repeat) {
                                clearInterval(intervalId);
                                isRunning = false;
                                startStopButton.textContent = 'Start';
                                endModal.style.display = 'flex';
                                return;
                            }
                        }
                        isRest = false;
                        currentTime = timer.intervals[currentIntervalIndex].durationInterval;
                        playSignal(globalSignals.intervalStart);
                    } else {
                        isRest = true;
                        currentTime = timer.intervals[currentIntervalIndex].durationRest;
                        playSignal(globalSignals.restStart);
                    }
                    if (currentTime === 3 && globalSignals.threeSecond) {
                        playSignal(globalSignals.threeSecond);
                    }
                }
                updateDisplay();
            }

            startStopButton.addEventListener('click', () => {
                if (isRunning) {
                    endModal.style.display = 'flex';
                } else {
                    isRunning = true;
                    startStopButton.textContent = 'Stop';
                    currentTime = timer.intervals[currentIntervalIndex].durationInterval;
                    playSignal(globalSignals.intervalStart);
                    intervalId = setInterval(tick, 1000);
                    if (window.audioContext.state === 'suspended') {
                        window.audioContext.resume().catch(e => console.error('Fehler beim Resumen:', e));
                    }
                }
            });

            cancelEndButton.addEventListener('click', () => {
                endModal.style.display = 'none';
            });

            confirmEndButton.addEventListener('click', () => {
                clearInterval(intervalId);
                isRunning = false;
                startStopButton.textContent = 'Start';
                endModal.style.display = 'none';
                currentIntervalIndex = 0;
                currentRepeat = 1;
                isRest = false;
                currentTime = timer.intervals[0].durationInterval;
                updateDisplay();
            });

            updateDisplay();
        });
    </script>
</body>
</html>