<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#01161E" />
    <title>Add Timer</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              dark: '#01161E',
              background: '#124559',
              primary: '#598392',
              secondary: '#AEC3B0',
              light: '#EFF6E0',
              accent: '#83c5be',
              rest: '#94d1be',
              interval: '#e76f51',
              warning: '#fc814a',
            },
            fontFamily: {
              karla: ['Karla', 'sans-serif'],
            }
          }
        }
      };
    </script>

    <link
      href="https://fonts.googleapis.com/css2?family=Karla:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        padding-top: env(safe-area-inset-top);
        background-color: #01161E;
        font-family: 'Karla', sans-serif;
        overscroll-behavior: none;
        scroll-padding-top: 4rem;
      }

      header {
        position: sticky;
        top: 0;
        z-index: 50;
        padding: 1rem;
        background-color: #01161E;
        transition: background-color 0.3s ease, backdrop-filter 0.3s ease;
      }

      header::before {
        content: "";
        position: absolute;
        top: -100vh;
        left: 0;
        right: 0;
        height: 100vh;
        background-color: #01161E;
        z-index: -1;
      }

      header.scrolled {
        background-color: rgba(1, 22, 30, 0.7);
        backdrop-filter: blur(6px);
      }

      .editor-content {
        padding-top: 0rem;
        padding-left: 1rem;
        padding-right: 1rem;
        padding-bottom: 1rem;
        gap: 1rem;
      }

      .interval-list {
        margin-top: 1rem;
        gap: 0.75rem;
      }

      .interval-item {
        margin-bottom: 1rem;
      }

      .interval-item > div:first-child {
          background-color: #124559;
          border: 1px solid rgba(239, 246, 224, 0.1); /* Korrigiert: #EFF6E0 mit 10% Opazität */
          border-radius: 0.75rem;
          padding: 0.75rem 1rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
          transition: opacity 0.3s ease;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
      }

      /* Spezifische Farbe für Rest-Intervalle im Editor */
      .interval-item.is-rest-type > div:first-child {
        background-color: #598392; /* Deine primary Farbe für Rest-Elemente im Editor */
      }

      .interval-item.options-active > div:first-child {
        opacity: 0.5;
      }

      .interval-item > div.absolute {
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        top: 0;
        left: 0;
        bottom: 0;
        background-color: #01161E;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
      }

      .interval-item > div.absolute.slide-in {
        transform: translateX(0%);
      }

      .interval-item > div.absolute.slide-out {
        transform: translateX(100%);
      }

      .interval-item > div.absolute span {
        color: #EFF6E0;
        cursor: pointer;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
      }

      .interval-item > div.absolute span:hover {
        opacity: 0.8;
      }

      .interval-item > div.absolute span.delete {
        color: #fc814a;
      }

      .sortable-chosen > div:first-child {
        background-color: #AEC3B0 !important;
      }

      .sort-icon-placeholder {
        width: 1rem;
        margin-right: 0.5rem;
        opacity: 0;
      }

      .interval-item.sortable-mode > div:first-child > span:first-child::before {
        content: '='; /* Unicode-Zeichen für den Sortier-Griff */
        color: #AEC3B0;
        margin-right: 0.5rem;
        display: inline-block;
        width: 1rem;
        opacity: 1;
      }
    </style>
  </head>

  <body class="text-light">
    <header id="header" class="text-light shadow-md">
      <div class="w-full flex justify-between items-center">
        <button class="text-accent font-semibold hover:underline" onclick="window.location.href='https://erikstadel.github.io/Timer-App/home-screen/index.html';">Back</button>
        <h1 class="text-xl font-bold text-accent tracking-wide">Add Timer</h1>
        <button
          id="saveButton"
          class="text-accent font-semibold hover:underline"
        >
          Save
        </button>
      </div>
    </header>

    <div class="editor-content pt-4">
      <div>
        <label class="block text-accent font-semibold mb-1">Timer Name</label>
        <input
          type="text"
          id="timerNameInput"
          placeholder="z.B. Boxrunde"
          class="w-full px-4 py-2 rounded-xl bg-light text-dark placeholder:text-dark/50 focus:outline-none focus:ring-2 focus:ring-accent"
        />
      </div>

      <div class="mt-6">
        <label class="block text-accent font-semibold mb-1">Repeat</label>
        <input
          type="number"
          id="repeatInput"
          min="1"
          value="1"
          class="w-full px-4 py-2 rounded-xl bg-light text-dark focus:outline-none focus:ring-2 focus:ring-accent"
        />
      </div>

      <div class="interval-list mt-6">
        <h2 class="text-accent font-semibold text-lg">Intervals</h2>
        <div id="intervalContainer"></div>
      </div>

      <button
        id="addIntervalButton"
        class="w-full bg-secondary text-dark rounded-xl py-2 font-semibold hover:bg-secondary/80 transition-all mt-6"
      >
        + Add Interval
      </button>
    </div>

    <script>
      const header = document.getElementById('header');
      const saveButton = document.getElementById('saveButton');
      const intervalContainer = document.getElementById('intervalContainer');
      const addIntervalButton = document.getElementById('addIntervalButton');
      const timerNameInput = document.getElementById('timerNameInput'); // Referenz auf Timer Name Input
      const repeatInput = document.getElementById('repeatInput');     // Referenz auf Repeat Input

      let activeOptionsItem = null;
      let sortableInstance = null;
      let longPressTimer = null;
      const longPressThreshold = 500; // Angepasste Schwelle für Longpress
      let isSortableMode = false;
      let touchStartX = 0;
      let touchStartY = 0;
      const swipeThreshold = 50;
      let currentListItem = null; // Speichert das aktuelle Listenelement für Touch-Operationen

      // **ANGEPASSTE DATENSTRUKTUR FÜR INTERVALS**
      // Jedes Intervall hat jetzt 'name', 'duration' (MM:SS) und 'type' ("interval" oder "rest")
      let intervals = [
        { id: 1, name: "Get Ready", duration: "00:10", type: "interval" },
        { id: 2, name: "Boxing Round", duration: "01:00", type: "interval" },
        { id: 3, name: "Rest", duration: "00:30", type: "rest" },
        { id: 4, name: "Kicking Drills", duration: "01:15", type: "interval" },
        { id: 5, name: "Cool Down", duration: "00:45", type: "interval" }
      ];

      renderIntervalList();

      // **HILFSFUNKTION: Formatiert die Dauer für die Anzeige im Editor**
      function formatTimeForEditor(durationString) {
          const parts = durationString.split(':');
          const minutes = parseInt(parts[0], 10);
          const seconds = parseInt(parts[1], 10);
          let formatted = [];
          if (minutes > 0) {
              formatted.push(`${minutes} Min`);
          }
          if (seconds > 0) {
              formatted.push(`${seconds} Sek`);
          }
          return formatted.join(' ') || "0 Sek"; // Vermeidet "0 Min 0 Sek"
      }


      function handleSwipe(listItem, deltaX) {
          if (deltaX < -swipeThreshold) {
              showOptions(listItem);
          } else if (deltaX > swipeThreshold) {
              closeOptions(listItem);
          }
      }

      function showOptions(listItem) {
          if (activeOptionsItem && activeOptionsItem !== listItem) {
              closeOptions(activeOptionsItem);
          }
          activeOptionsItem = listItem;

          let optionsElement = listItem.querySelector('.absolute');
          if (!optionsElement) {
              optionsElement = document.createElement('div');
              optionsElement.classList.add('absolute', 'top-0', 'left-0', 'bottom-0', 'bg-dark', 'flex', 'items-center', 'justify-center', 'transform', 'translate-x-full', 'transition-transform', 'duration-300', 'w-full');
              optionsElement.innerHTML = `
                  <span class="text-light cursor-pointer clone-button">Clone</span>
                  <span class="text-warning cursor-pointer delete-button ml-4">Delete</span>
              `;
              listItem.appendChild(optionsElement);

              const cloneButton = optionsElement.querySelector('.clone-button');
              const deleteButton = optionsElement.querySelector('.delete-button');

              cloneButton.addEventListener('click', () => {
                  const itemId = parseInt(listItem.dataset.intervalId);
                  cloneInterval(itemId);
                  closeOptions(listItem); // Optionen nach dem Klonen schließen
              });

              deleteButton.addEventListener('click', () => {
                  const itemId = parseInt(listItem.dataset.intervalId);
                  deleteInterval(itemId);
              });
          }

          setTimeout(() => {
              optionsElement.classList.remove('translate-x-full');
              optionsElement.classList.add('slide-in');
              listItem.classList.add('options-active');
          }, 0);
      }

      function closeOptions(listItem) {
          const optionsElement = listItem.querySelector('.absolute');
          if (optionsElement) {
              optionsElement.classList.remove('slide-in');
              optionsElement.classList.add('slide-out');
              listItem.classList.remove('options-active');
              setTimeout(() => {
                  if (optionsElement && optionsElement.parentNode === listItem) {
                      optionsElement.remove();
                  }
                  activeOptionsItem = null;
              }, 300);
          }
      }

      function cloneInterval(itemId) {
          const indexToClone = intervals.findIndex(item => item.id === itemId);
          if (indexToClone !== -1) {
              // **CLONE LOGIK: Füge eine neue ID hinzu**
              const clonedInterval = { ...intervals[indexToClone], id: Date.now() };
              intervals.splice(indexToClone + 1, 0, clonedInterval);
              renderIntervalList();
          }
      }

      function deleteInterval(itemId) {
          const indexToDelete = intervals.findIndex(item => item.id === itemId);
          if (indexToDelete !== -1 && confirm(`Möchtest du dieses Intervall wirklich löschen?`)) {
              intervals.splice(indexToDelete, 1);
              renderIntervalList();
          }
      }

      // **ANGEPASSTE renderIntervalList FUNKTION**
      function renderIntervalList() {
          intervalContainer.innerHTML = '';
          intervals.forEach(interval => {
              const listItem = document.createElement('div');
              listItem.classList.add('interval-item', 'relative', 'overflow-hidden', 'user-select-none');
              listItem.dataset.intervalId = interval.id; // Wichtig für die Identifizierung

              // Füge spezifische Klasse basierend auf dem Typ hinzu für visuelle Unterscheidung
              if (interval.type === 'rest') {
                  listItem.classList.add('is-rest-type');
              } else {
                  listItem.classList.add('is-interval-type');
              }

              listItem.innerHTML = `
                  <div class="bg-background border border-light/10 rounded-xl px-4 py-3 flex justify-between items-center transition-opacity duration-300">
                      <span><span class="sort-icon-placeholder"></span>${interval.name}</span>
                      <span class="text-sm text-accent">${formatTimeForEditor(interval.duration)}</span>
                  </div>
              `;

              // **Event Listener zum Öffnen des Intervall-Popups zum Bearbeiten**
              listItem.querySelector('div:first-child').addEventListener('click', (e) => {
                  // Verhindere, dass der Klick die Optionen schließt, wenn sie aktiv sind
                  if (activeOptionsItem === listItem) return;
                  if (isSortableMode) return; // Nicht öffnen, wenn im Sortier-Modus

                  const itemId = parseInt(listItem.dataset.intervalId);
                  const intervalToEdit = intervals.find(item => item.id === itemId);

                  if (intervalToEdit) {
                      // Öffne das Popup und übergebe die Daten
                      // WICHTIG: Die URL zum interval-editor.html muss korrekt sein
                      const popupWindow = window.open('interval-editor.html', '_blank', 'width=400,height=600');
                      
                      // Sobald das Popup geladen ist, sende die Daten
                      // Event listener für 'load' des Popups
                      popupWindow.addEventListener('load', () => {
                        if (popupWindow && !popupWindow.closed) { // Stelle sicher, dass das Fenster noch offen ist
                            popupWindow.postMessage({
                                type: 'loadInterval',
                                data: intervalToEdit
                            }, window.location.origin); // Sende die Daten an das Popup
                        }
                      }, { once: true }); // Führt den Listener nur einmal aus
                  }
              });


              let startX = 0;
              let startY = 0;
              let isSwiping = false;
              let isLongPress = false;
              let longPressTimeout;

              listItem.addEventListener('touchstart', (e) => {
                  if (!isSortableMode) {
                      currentListItem = listItem;
                      startX = e.touches[0].clientX;
                      startY = e.touches[0].clientY;
                      isSwiping = false;
                      isLongPress = false;
                      longPressTimeout = setTimeout(() => {
                          isLongPress = true;
                          enableSortableMode();
                      }, longPressThreshold);
                  }
              });

              listItem.addEventListener('touchmove', (e) => {
                  if (!isSortableMode && currentListItem === listItem) {
                      const currentX = e.touches[0].clientX;
                      const currentY = e.touches[0].clientY;
                      const deltaX = Math.abs(currentX - startX);
                      const deltaY = Math.abs(currentY - startY);

                      if (deltaX > 10 || deltaY > 10) { // Genug Bewegung, um Swipe/Scroll zu erkennen
                          isSwiping = true;
                          clearTimeout(longPressTimeout);
                      }
                  }
              });

              listItem.addEventListener('touchend', (e) => {
                  if (!isSortableMode && currentListItem === listItem) {
                      clearTimeout(longPressTimeout);
                      if (!isLongPress && isSwiping) { // War ein Swipe, kein Longpress
                          const endX = e.changedTouches[0].clientX;
                          const deltaX = startX - endX;
                          handleSwipe(listItem, deltaX);
                      }
                      startX = 0;
                      startY = 0;
                      isSwiping = false;
                      isLongPress = false;
                      currentListItem = null;
                  }
              });

              // Verhindern des Kontextmenüs bei langem Drücken (optional)
              listItem.addEventListener('contextmenu', (e) => {
                  if (!isSortableMode) {
                      e.preventDefault();
                  }
              });

              intervalContainer.appendChild(listItem);
          });

          if (isSortableMode) {
              enableSortable();
          } else if (sortableInstance) {
              sortableInstance.destroy();
              sortableInstance = null;
          }
      }

      function enableSortableMode() {
          isSortableMode = true;
          saveButton.textContent = 'Save Order';
          const listItems = intervalContainer.querySelectorAll('.interval-item');
          listItems.forEach(item => item.classList.add('sortable-mode'));
          if (activeOptionsItem) { // Wenn Optionen offen sind, schließen
              closeOptions(activeOptionsItem);
          }
          enableSortable();
      }

      function disableSortableMode() {
          isSortableMode = false;
          saveButton.textContent = 'Save';
          const listItems = intervalContainer.querySelectorAll('.interval-item');
          listItems.forEach(item => item.classList.remove('sortable-mode'));
          if (sortableInstance) {
              sortableInstance.destroy();
              sortableInstance = null;
          }
          console.log("Neue Reihenfolge der Intervalle:", intervals.map(i => i.id));
      }

      function enableSortable() {
          if (!sortableInstance) {
              sortableInstance = new Sortable(intervalContainer, {
                  animation: 150,
                  handle: '.sort-icon-placeholder', // Nur über das '=' Zeichen ziehen
                  onEnd: function (evt) {
                      const newIntervals = [];
                      Array.from(intervalContainer.children).forEach(item => {
                          const id = parseInt(item.dataset.intervalId);
                          const foundInterval = intervals.find(interval => interval.id === id);
                          if (foundInterval) {
                              newIntervals.push(foundInterval);
                          }
                      });
                      intervals = newIntervals;
                  },
              });
          }
      }

      saveButton.addEventListener('click', () => {
          if (isSortableMode) {
              disableSortableMode();
              // Logik zum Speichern der neuen Reihenfolge könnte hier folgen (z.B. in localStorage)
          } else {
              // **LOGIK FÜR DAS SPEICHERN DES GESAMTEN TIMERS**
              const timerName = timerNameInput.value.trim();
              const repeatCount = parseInt(repeatInput.value, 10);

              const timerData = {
                  name: timerName,
                  repeat: repeatCount,
                  intervals: intervals // Das aktualisierte Array von Intervallen
              };

              console.log("Timer gespeichert:", timerData);
              // Hier würdest du timerData in localStorage speichern oder an eine API senden
              localStorage.setItem('currentTimerForReview', JSON.stringify(timerData));
              
              // Optional: Zur Review-Seite oder Home-Seite navigieren
              window.location.href = 'review.html'; // Passe den Pfad an
          }
      });

      addIntervalButton.addEventListener('click', () => {
          const newId = Date.now();
          // **NEUES INTERVALL MIT STANDARDTYP "interval" HINZUFÜGEN**
          intervals.push({ id: newId, name: `New Interval`, duration: "00:00", type: "interval" });
          renderIntervalList();
          // Optional: Scroll zum neuen Intervall
          intervalContainer.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'end' });
      });

      window.addEventListener('scroll', () => {
          if (window.scrollY > 0) {
              header.classList.add('scrolled');
          } else {
              header.classList.remove('scrolled');
          }
      });

      document.addEventListener('click', (event) => {
          const openOptions = document.querySelector('.interval-item.options-active .absolute');
          if (openOptions && !event.target.closest('.interval-item')) {
              const activeListItem = document.querySelector('.interval-item.options-active');
              if (activeListItem) {
                  closeOptions(activeListItem);
              }
          }
      });

      // **Empfangen von Nachrichten vom Intervall-Editor (Popup)**
      window.addEventListener('message', (event) => {
          // Wichtig: Prüfe event.origin für Sicherheit in einer echten Anwendung
          // if (event.origin !== window.location.origin) { // Oder die spezifische Origin deines interval-editors
          //     return;
          // }

          if (event.data && event.data.type === 'saveInterval') {
              const updatedInterval = event.data.data;
              const index = intervals.findIndex(item => item.id === updatedInterval.id);

              if (index !== -1) {
                  // Aktualisiere das bestehende Intervall mit den neuen Daten
                  intervals[index] = { ...intervals[index], ...updatedInterval };
              } else {
                  // Dies sollte nur passieren, wenn ein Intervall im Popup erstellt wurde,
                  // ohne dass es vorher im Timer-Editor existierte.
                  // In deinem Fall wird es immer eine ID haben, da du es zum Bearbeiten sendest.
                  console.warn("Received update for unknown interval ID:", updatedInterval.id);
                  // Optional: füge es hinzu, wenn es wirklich neu ist:
                  // intervals.push(updatedInterval);
              }
              renderIntervalList(); // Liste neu rendern, um Änderungen zu zeigen
          }
      });

      // **Initialisierung des Timer-Editors beim Laden**
      // Hier könntest du gespeicherte Timer-Daten laden (z.B. aus localStorage),
      // wenn du einen bestehenden Timer bearbeiten möchtest.
      document.addEventListener('DOMContentLoaded', () => {
          // Beispiel: Laden eines Timers aus localStorage, wenn eine ID in der URL ist
          // const urlParams = new URLSearchParams(window.location.search);
          // const timerId = urlParams.get('timerId');
          // if (timerId) {
          //     const savedTimers = JSON.parse(localStorage.getItem('timers') || '[]');
          //     const timerToLoad = savedTimers.find(t => t.id === timerId);
          //     if (timerToLoad) {
          //         timerNameInput.value = timerToLoad.name;
          //         repeatInput.value = timerToLoad.repeat;
          //         intervals = timerToLoad.intervals;
          //         renderIntervalList();
          //     }
          // }

          // Aktuelle Initialisierung für den "Add Timer" Anwendungsfall:
          // Sicherstellen, dass die initialen Intervalle gerendert werden
          renderIntervalList();
      });

    </script>
  </body>
</html>