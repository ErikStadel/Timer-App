<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#01161E" />
    <title>Add Timer</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              dark: '#01161E',
              background: '#124559',
              primary: '#598392',
              secondary: '#AEC3B0',
              light: '#EFF6E0',
              accent: '#83c5be',
              rest: '#94d1be',
              interval: '#e76f51',
              warning: '#fc814a',
            },
            fontFamily: {
              karla: ['Karla', 'sans-serif'],
            }
          }
        }
      };
    </script>

    <link
      href="https://fonts.googleapis.com/css2?family=Karla:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        padding-top: env(safe-area-inset-top);
        background-color: #01161E;
        font-family: 'Karla', sans-serif;
        overscroll-behavior: none;
        scroll-padding-top: 4rem;
        color: #EFF6E0; /* Added for general text color */
      }

      header {
        position: sticky;
        top: 0;
        z-index: 50;
        padding: 1rem;
        background-color: #01161E;
        transition: background-color 0.3s ease, backdrop-filter 0.3s ease;
      }

      header::before {
        content: "";
        position: absolute;
        top: -100vh;
        left: 0;
        right: 0;
        height: 100vh;
        background-color: #01161E;
        z-index: -1;
      }

      header.scrolled {
        background-color: rgba(1, 22, 30, 0.7);
        backdrop-filter: blur(6px);
      }

      .editor-content {
        padding-top: 0rem;
        padding-left: 1rem;
        padding-right: 1rem;
        padding-bottom: 1rem;
        gap: 1rem;
      }

      .interval-list {
        margin-top: 1rem;
        gap: 0.75rem;
      }

      .interval-item {
        margin-bottom: 1rem;
        position: relative; /* For swipe options positioning */
        overflow: hidden; /* To hide overflow of swipe options */
      }

      .interval-item > div:first-child {
          background-color: #124559;
          border: 1px solid rgba(239, 246, 224, 0.1);
          border-radius: 0.75rem;
          padding: 0.75rem 1rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
          transition: opacity 0.3s ease;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
      }

      .interval-item.is-rest-type > div:first-child {
        background-color: #598392;
      }

      .interval-item.options-active > div:first-child {
        opacity: 0.5;
      }

      /* Swipe Options Container */
      .interval-item > div.swipe-options-container { /* Added new class for consistency */
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        position: absolute; /* Ensure it's absolutely positioned */
        top: 0;
        left: 0;
        bottom: 0;
        background-color: #01161E;
        width: 100%; /* Cover the whole item */
        display: flex;
        align-items: center;
        justify-content: space-around; /* Distribute options */
        padding: 0 1rem; /* Padding for the options */
      }

      .interval-item > div.swipe-options-container.slide-in {
        transform: translateX(0%);
      }

      .interval-item > div.swipe-options-container.slide-out {
        transform: translateX(100%);
      }

      .interval-item > div.swipe-options-container span {
        color: #EFF6E0;
        cursor: pointer;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        white-space: nowrap; /* Prevent text wrapping */
      }

      .interval-item > div.swipe-options-container span:hover {
        opacity: 0.8;
      }

      .interval-item > div.swipe-options-container span.delete {
        color: #fc814a;
      }

      .sortable-chosen > div:first-child {
        background-color: #AEC3B0 !important;
      }

      /* Handle for sortable */
      .sort-icon-placeholder {
        width: 1.5rem; /* Make it wider for easier grabbing */
        margin-right: 0.5rem;
        opacity: 0;
        text-align: center; /* Center the '=' */
        cursor: grab; /* Indicate it's draggable */
        transition: opacity 0.3s ease;
      }

      .interval-item.sortable-mode .sort-icon-placeholder {
        opacity: 1;
      }

      .interval-item.sortable-mode .sort-icon-placeholder::before {
        content: '='; /* Unicode-Zeichen f√ºr den Sortier-Griff */
        color: #AEC3B0;
        display: inline-block;
        /* No need for width/margin here as it's handled by .sort-icon-placeholder itself */
      }

      /* Confirmation Dialog Styles (Copied from home-screen.html) */
      .confirmation-dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.6);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 100;
          opacity: 0;
          visibility: hidden;
          transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .confirmation-dialog-overlay.active {
          opacity: 1;
          visibility: visible;
      }

      .confirmation-dialog {
          background-color: #124559;
          color: #EFF6E0;
          padding: 1.5rem;
          border-radius: 0.75rem;
          text-align: center;
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
          max-width: 80%;
          min-width: 280px;
      }

      .confirmation-dialog p {
          font-size: 1.1rem;
          margin-bottom: 1.5rem;
      }

      .confirmation-dialog-buttons {
          display: flex;
          justify-content: space-around;
          gap: 1rem;
      }

      .btn-cancel, .btn-confirm {
          padding: 0.75rem 1.5rem;
          border-radius: 0.5rem;
          font-weight: bold;
          cursor: pointer;
          border: none;
          font-size: 1rem;
          flex-grow: 1;
      }

      .btn-cancel {
          background-color: #598392;
          color: #EFF6E0;
      }

      .btn-cancel:hover {
          background-color: #AEC3B0;
      }

      .btn-confirm {
          background-color: #e76f51;
          color: #EFF6E0;
      }

      .btn-confirm:hover {
          background-color: #fc814a;
      }
    </style>
  </head>

  <body class="text-light">
    <header id="header" class="text-light shadow-md">
      <div class="w-full flex justify-between items-center">
        <button class="text-accent font-semibold hover:underline" onclick="window.location.href='../home-screen/index.html';">Back</button>
        <h1 id="headerTitle" class="text-xl font-bold text-accent tracking-wide">Add Timer</h1>
        <button
          id="saveButton"
          class="text-accent font-semibold hover:underline"
        >
          Save
        </button>
      </div>
    </header>

    <div class="editor-content pt-4">
      <div>
        <label class="block text-accent font-semibold mb-1">Timer Name</label>
        <input
          type="text"
          id="timerNameInput"
          placeholder="z.B. Boxrunde"
          class="w-full px-4 py-2 rounded-xl bg-light text-dark placeholder:text-dark/50 focus:outline-none focus:ring-2 focus:ring-accent"
        />
      </div>

      <div class="mt-6">
        <label class="block text-accent font-semibold mb-1">Repeat</label>
        <input
          type="number"
          id="repeatInput"
          min="1"
          value="1"
          class="w-full px-4 py-2 rounded-xl bg-light text-dark focus:outline-none focus:ring-2 focus:ring-accent"
        />
      </div>

      <div class="interval-list mt-6">
        <h2 class="text-accent font-semibold text-lg">Intervals</h2>
        <div id="intervalContainer"></div>
      </div>

      <button
        id="addIntervalButton"
        class="w-full bg-secondary text-dark rounded-xl py-2 font-semibold hover:bg-secondary/80 transition-all mt-6"
      >
        + Add Interval
      </button>
    </div>

    <div class="confirmation-dialog-overlay" id="deleteConfirmationDialog">
        <div class="confirmation-dialog">
            <p>Delete Interval?</p>
            <div class="confirmation-dialog-buttons">
                <button class="btn-cancel" id="cancelDelete">Cancel</button>
                <button class="btn-confirm" id="confirmDelete">Delete</button>
            </div>
        </div>
    </div>

    <script>
      const header = document.getElementById('header');
      const headerTitle = document.getElementById('headerTitle');
      const saveButton = document.getElementById('saveButton');
      const intervalContainer = document.getElementById('intervalContainer');
      const addIntervalButton = document.getElementById('addIntervalButton');
      const timerNameInput = document.getElementById('timerNameInput');
      const repeatInput = document.getElementById('repeatInput');

      const deleteConfirmationDialog = document.getElementById('deleteConfirmationDialog');
      const cancelDeleteButton = document.getElementById('cancelDelete');
      const confirmDeleteButton = document.getElementById('confirmDelete');

      let activeOptionsItem = null;
      let sortableInstance = null;
      let longPressTimer = null;
      const longPressThreshold = 500;
      let isSortableMode = false;
      let touchStartX = 0;
      let touchStartY = 0;
      const swipeThreshold = 50;
      let currentListItem = null; // Stores the current list item for touch operations

      let currentTimerId = null; // Stores the ID of the timer being edited
      let intervals = []; // This will hold the intervals for the current timer

      // --- Helper Functions for Data Management (consistent with home-screen) ---
      function generateUniqueId() {
          return `timer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      }

      function loadTimers() {
          let storedTimers = JSON.parse(localStorage.getItem('timers') || '[]');
          let needsUpdate = false;
          // Ensure all timers have an ID and correct intervals/repeat structure
          storedTimers.forEach(timer => {
              if (!timer.id) {
                  timer.id = generateUniqueId();
                  needsUpdate = true;
              }
              if (!timer.intervals || !Array.isArray(timer.intervals) || timer.intervals.length === 0) {
                  // Attempt to convert old "duration" string to new "intervals" structure
                  if (timer.duration && typeof timer.duration === 'string' && timer.duration.includes(':')) {
                      const parts = timer.duration.split(':');
                      const totalSeconds = parseInt(parts[0]) * 60 + parseInt(parts[1]);
                      timer.intervals = [{ duration: totalSeconds, type: 'work' }];
                  } else {
                      timer.intervals = [{ duration: 300, type: 'work' }]; // Default 5 minutes if no valid duration
                  }
                  needsUpdate = true;
              }
              if (timer.repeat === undefined) {
                  timer.repeat = 1;
                  needsUpdate = true;
              }
              // Remove old `duration` property if it exists to clean up
              if (timer.duration !== undefined && typeof timer.duration === 'string') {
                  delete timer.duration;
                  needsUpdate = true;
              }
          });
          if (needsUpdate) {
              saveTimers(storedTimers);
          }
          return storedTimers;
      }

      function saveTimers(currentTimers) {
          localStorage.setItem('timers', JSON.stringify(currentTimers));
      }
      // --- End Helper Functions ---

      // Helper function: Format time for editor display (e.g., "1 Min 30 Sek")
      function formatTimeForEditor(durationString) {
          if (!durationString || !durationString.includes(':')) {
              return "0 Sek";
          }
          const parts = durationString.split(':');
          const minutes = parseInt(parts[0], 10);
          const seconds = parseInt(parts[1], 10);
          let formatted = [];
          if (minutes > 0) {
              formatted.push(`${minutes} Min`);
          }
          if (seconds > 0) {
              formatted.push(`${seconds} Sek`);
          }
          return formatted.join(' ') || "0 Sek";
      }

      // --- Swipe Logic (Adjusted for direction) ---
      function handleSwipe(listItem, deltaX) {
        // Original: deltaX < -swipeThreshold (swipe left) -> show options
        // New: deltaX > swipeThreshold (swipe right) -> show options
        // Original: deltaX > swipeThreshold (swipe right) -> close options
        // New: deltaX < -swipeThreshold (swipe left) -> close options

        // Swipe Right to show options
        if (deltaX > swipeThreshold) {
          showOptions(listItem);
        }
        // Swipe Left to close options (if any are active)
        else if (deltaX < -swipeThreshold) {
          closeOptions(listItem);
        } else {
            // If swipe was not significant enough, but an option panel was open, close it
            if (listItem.classList.contains('options-active')) {
                closeOptions(listItem);
            }
        }
      }

      function showOptions(listItem) {
          if (activeOptionsItem && activeOptionsItem !== listItem) {
              closeOptions(activeOptionsItem);
          }
          activeOptionsItem = listItem;

          let optionsElement = listItem.querySelector('.swipe-options-container'); // Use new class
          if (!optionsElement) {
              optionsElement = document.createElement('div');
              optionsElement.classList.add('swipe-options-container', 'bg-dark', 'w-full', 'h-full', 'flex', 'items-center', 'justify-around', 'absolute', 'transform', 'translate-x-full', 'transition-transform', 'duration-300');
              optionsElement.innerHTML = `
                  <span class="text-light cursor-pointer clone-button">Clone</span>
                  <span class="text-warning cursor-pointer delete-button ml-4">Delete</span>
              `;
              listItem.appendChild(optionsElement);

              const cloneButton = optionsElement.querySelector('.clone-button');
              const deleteButton = optionsElement.querySelector('.delete-button');

              cloneButton.addEventListener('click', (e) => {
                  e.stopPropagation(); // Prevent li click
                  const itemId = listItem.dataset.intervalId;
                  cloneInterval(itemId);
                  closeOptions(listItem);
              });

              deleteButton.addEventListener('click', (e) => {
                  e.stopPropagation(); // Prevent li click
                  const itemId = listItem.dataset.intervalId;
                  showDeleteConfirmation(itemId); // Use the confirmation dialog
              });
          }

          setTimeout(() => {
              optionsElement.classList.remove('translate-x-full');
              optionsElement.classList.add('slide-in');
              listItem.classList.add('options-active');
          }, 0);
      }

      function closeOptions(listItem) {
          const optionsElement = listItem.querySelector('.swipe-options-container'); // Use new class
          if (optionsElement) {
              optionsElement.classList.remove('slide-in');
              optionsElement.classList.add('slide-out');
              listItem.classList.remove('options-active');
              setTimeout(() => {
                  if (optionsElement && optionsElement.parentNode === listItem) {
                      optionsElement.remove();
                  }
                  activeOptionsItem = null;
              }, 300);
          }
      }

      function cloneInterval(itemId) {
          const indexToClone = intervals.findIndex(item => item.id === itemId);
          if (indexToClone !== -1) {
              const clonedInterval = { ...intervals[indexToClone], id: generateUniqueId() };
              intervals.splice(indexToClone + 1, 0, clonedInterval);
              renderIntervalList();
          }
      }

      // --- Confirmation Dialog and Delete Logic (Copied from home-screen) ---
      let intervalToDeleteId = null;

      function showDeleteConfirmation(intervalId) {
          intervalToDeleteId = intervalId;
          deleteConfirmationDialog.classList.add('active');
      }

      function hideDeleteConfirmation() {
          deleteConfirmationDialog.classList.remove('active');
          intervalToDeleteId = null;
          if (activeOptionsItem) {
              closeOptions(activeOptionsItem); // Ensure options are closed
          }
      }

      cancelDeleteButton.addEventListener('click', hideDeleteConfirmation);
      confirmDeleteButton.addEventListener('click', () => {
          if (intervalToDeleteId) {
              deleteIntervalConfirmed(intervalToDeleteId); // New function name
              hideDeleteConfirmation();
          }
      });

      function deleteIntervalConfirmed(idToDelete) { // Renamed from deleteInterval
          let newIntervals = intervals.filter(item => item.id !== idToDelete);
          intervals = newIntervals;
          renderIntervalList();
      }
      // --- End Confirmation Dialog and Delete Logic ---


      function renderIntervalList() {
          intervalContainer.innerHTML = '';
          if (intervals.length === 0) {
              const noIntervalsMessage = document.createElement('div');
              noIntervalsMessage.classList.add('text-center', 'text-secondary', 'mt-4', 'p-4', 'rounded-xl', 'bg-background');
              noIntervalsMessage.textContent = 'No intervals yet. Tap "+ Add Interval" to create one.';
              intervalContainer.appendChild(noIntervalsMessage);
              return;
          }

          intervals.forEach(interval => {
              const listItem = document.createElement('div');
              listItem.classList.add('interval-item'); // Remove 'relative', 'overflow-hidden', 'user-select-none' here as they are in the style block
              listItem.dataset.intervalId = interval.id;

              if (interval.type === 'rest') {
                  listItem.classList.add('is-rest-type');
              } else {
                  listItem.classList.add('is-interval-type');
              }
              
              if (isSortableMode) { // Apply sortable-mode class if already in that mode
                listItem.classList.add('sortable-mode');
              }

              listItem.innerHTML = `
                  <div class="bg-background border border-light/10 rounded-xl px-4 py-3 flex justify-between items-center transition-opacity duration-300">
                      <span class="sort-icon-placeholder"></span><span class="interval-name-display">${interval.name}</span>
                      <span class="text-sm text-accent">${formatTimeForEditor(interval.duration)}</span>
                  </div>
              `;

              // Event Listener to open the interval-editor popup
              listItem.querySelector('div:first-child').addEventListener('click', (e) => {
                  if (activeOptionsItem === listItem) return;
                  if (isSortableMode) return;

                  const itemId = listItem.dataset.intervalId;
                  const intervalToEdit = intervals.find(item => item.id === itemId);

                  if (intervalToEdit) {
                      const popupWindow = window.open('interval-editor.html', '_blank', 'width=400,height=600');
                      
                      popupWindow.addEventListener('load', () => {
                          if (popupWindow && !popupWindow.closed) {
                              popupWindow.postMessage({
                                  type: 'loadInterval',
                                  data: intervalToEdit
                              }, window.location.origin);
                          }
                      }, { once: true });
                  }
              });

              let startX = 0;
              let startY = 0;
              let isSwipingOrScrolling = false; // Combined flag for any significant movement
              let isLongPress = false;
              let longPressTimeout;
              let movementThreshold = 10; // Threshold for any movement (swipe or scroll)


              listItem.addEventListener('touchstart', (e) => {
                  if (!isSortableMode) {
                      touchStartX = e.touches[0].clientX;
                      touchStartY = e.touches[0].clientY;
                      isSwipingOrScrolling = false;
                      isLongPress = false;
                      
                      // Close any active options if starting a new touch on a different item
                      if (activeOptionsItem && activeOptionsItem !== listItem) {
                          closeOptions(activeOptionsItem);
                      }

                      longPressTimeout = setTimeout(() => {
                          if (!isSwipingOrScrolling) { // Only activate sortable mode if no significant movement occurred
                              e.preventDefault(); // Prevent accidental click after long press
                              isLongPress = true;
                              enableSortableMode();
                          }
                      }, longPressThreshold);
                  }
              }, { passive: false }); // Passive: false to allow preventDefault

              listItem.addEventListener('touchmove', (e) => {
                  if (!isSortableMode) {
                      const currentX = e.touches[0].clientX;
                      const currentY = e.touches[0].clientY;
                      const deltaX = currentX - touchStartX;
                      const deltaY = currentY - touchStartY;

                      if (Math.abs(deltaX) > movementThreshold || Math.abs(deltaY) > movementThreshold) {
                          isSwipingOrScrolling = true;
                          clearTimeout(longPressTimeout); // Cancel long press if moving

                          // If it's a horizontal swipe, prevent default to avoid scrolling
                          if (Math.abs(deltaX) > Math.abs(deltaY)) {
                              e.preventDefault();
                              // Optional: Visually show the options sliding with the finger
                              const optionsElement = listItem.querySelector('.swipe-options-container');
                              if (optionsElement) {
                                  // Clamping the value to prevent options from moving too far left/right
                                  // Swipe right (deltaX > 0) means options slide in from right to left (transformX goes from 100% down to 0%)
                                  const newTransformX = Math.max(0, 100 - (deltaX / listItem.offsetWidth) * 100);
                                  optionsElement.style.transform = `translateX(${newTransformX}%)`;
                              }
                          }
                      }
                  }
              }, { passive: false });

              listItem.addEventListener('touchend', (e) => {
                  if (!isSortableMode) {
                      clearTimeout(longPressTimeout);
                      if (!isLongPress && isSwipingOrScrolling) { // It was a swipe or scroll gesture
                          const endX = e.changedTouches[0].clientX;
                          const deltaX = endX - touchStartX; // Swipe direction
                          
                          // If primarily horizontal movement (swipe), handle it
                          if (Math.abs(deltaX) > Math.abs(e.changedTouches[0].clientY - touchStartY)) {
                              handleSwipe(listItem, deltaX); // Call original handleSwipe for decision
                          } else {
                              // If primarily vertical movement (scroll), just close options if any were open
                              if (listItem.classList.contains('options-active')) {
                                  closeOptions(listItem);
                              }
                          }
                           // Reset transform for swipe options after handling the gesture
                          const optionsElement = listItem.querySelector('.swipe-options-container');
                          if (optionsElement) {
                              optionsElement.style.transform = ''; // Reset transform for transition
                          }
                      } else if (!isLongPress && !isSwipingOrScrolling) { // It was a tap (no significant movement or long press)
                          // Already handled by the click listener on the internal div
                      }
                  }
                  isSwipingOrScrolling = false;
                  isLongPress = false; // Reset long press state
                  touchStartX = 0;
                  touchStartY = 0;
              });

              listItem.addEventListener('contextmenu', (e) => {
                  e.preventDefault(); // Prevent default context menu on long press
              });

              intervalContainer.appendChild(listItem);
          });

          if (isSortableMode) {
              enableSortable();
          } else if (sortableInstance) {
              sortableInstance.destroy();
              sortableInstance = null;
          }
      }

      function enableSortableMode() {
          isSortableMode = true;
          saveButton.textContent = 'Save Order';
          const listItems = intervalContainer.querySelectorAll('.interval-item');
          listItems.forEach(item => item.classList.add('sortable-mode'));
          if (activeOptionsItem) { // If options open, close them
              closeOptions(activeOptionsItem);
          }
          enableSortable();
      }

      function disableSortableMode() {
          isSortableMode = false;
          saveButton.textContent = 'Save';
          const listItems = intervalContainer.querySelectorAll('.interval-item');
          listItems.forEach(item => item.classList.remove('sortable-mode'));
          if (sortableInstance) {
              sortableInstance.destroy(); // Destroy to clean up listeners and allow re-init on next sort
              sortableInstance = null;
          }
          renderIntervalList(); // Re-render to ensure correct appearance and event listeners
      }

      function enableSortable() {
          if (!sortableInstance) {
              sortableInstance = new Sortable(intervalContainer, {
                  animation: 150,
                  handle: '.sort-icon-placeholder', // This is the element to drag by
                  filter: '.swipe-options-container', // Prevents dragging when clicking on swipe options
                  preventOnFilter: false, // Allows click events on filtered elements
                  dataIdAttr: 'data-interval-id', // Use data-interval-id for Sortable's internal ID management
                  onEnd: function (evt) {
                      // SortableJS automatically updates the DOM. We need to update our `intervals` array.
                      const newOrderIds = sortableInstance.toArray(); // Get IDs in new order
                      const newIntervals = newOrderIds.map(id => intervals.find(item => item.id === id));
                      intervals = newIntervals; // Update global intervals array with new order
                  },
              });
          }
      }

      saveButton.addEventListener('click', () => {
          if (isSortableMode) {
              disableSortableMode();
              // When disabling sortable mode, the intervals array is already updated by onEnd,
              // and renderIntervalList is called, so data is in sync.
          } else {
              const timerName = timerNameInput.value.trim();
              const repeatCount = parseInt(repeatInput.value, 10);

              if (!timerName) {
                  alert('Timer name cannot be empty.');
                  return;
              }
              if (isNaN(repeatCount) || repeatCount < 1) {
                  alert('Repeat count must be at least 1.');
                  return;
              }
              if (intervals.length === 0) {
                  alert('A timer must have at least one interval.');
                  return;
              }

              let allTimers = loadTimers();
              let timerToSave = {
                  id: currentTimerId || generateUniqueId(), // Use existing ID or generate new
                  name: timerName,
                  repeat: repeatCount,
                  intervals: intervals.map(interval => ({ // Ensure durations are numbers for saving
                      id: interval.id,
                      name: interval.name,
                      duration: interval.duration, // Keep as MM:SS string for consistency
                      type: interval.type
                  }))
              };

              if (currentTimerId) {
                  // Editing existing timer
                  const index = allTimers.findIndex(t => t.id === currentTimerId);
                  if (index !== -1) {
                      allTimers[index] = timerToSave;
                  } else {
                      // This path should ideally not be taken if currentTimerId is managed correctly
                      console.warn("Attempted to update a timer that was not found. Adding as new.");
                      allTimers.push(timerToSave);
                  }
              } else {
                  // Adding new timer
                  allTimers.push(timerToSave);
              }

              saveTimers(allTimers);
              localStorage.removeItem('selectedTimerId'); // Clear selected ID after saving
              window.location.href = '../home-screen/index.html'; // Navigate back to home
          }
      });

      addIntervalButton.addEventListener('click', () => {
          const newId = generateUniqueId();
          intervals.push({ id: newId, name: `New Interval`, duration: "00:00", type: "work" }); // Default type "work"
          renderIntervalList();
          intervalContainer.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'end' });
      });

      window.addEventListener('scroll', () => {
          if (window.scrollY > 0) {
              header.classList.add('scrolled');
          } else {
              header.classList.remove('scrolled');
          }
      });

      document.addEventListener('click', (event) => {
          const openOptions = document.querySelector('.interval-item.options-active .swipe-options-container'); // Check for the options container
          if (openOptions && !event.target.closest('.interval-item')) { // If options are open AND the click was outside the item
              const activeListItem = document.querySelector('.interval-item.options-active');
              if (activeListItem) {
                  closeOptions(activeListItem);
              }
          }
      });

      // Receive updates from interval-editor popup
      window.addEventListener('message', (event) => {
          if (event.data && event.data.type === 'saveInterval') {
              const updatedInterval = event.data.data;
              const index = intervals.findIndex(item => item.id === updatedInterval.id);

              if (index !== -1) {
                  intervals[index] = { ...intervals[index], ...updatedInterval };
              } else {
                  console.warn("Received update for unknown interval ID:", updatedInterval.id);
                  // Optionally add if this is a new interval being created from popup (not current workflow)
                  // intervals.push(updatedInterval);
              }
              renderIntervalList(); // Re-render to show updated interval name/duration/type
          }
      });

      // Initialization logic for Timer Editor
      document.addEventListener('DOMContentLoaded', () => {
          const selectedTimerId = localStorage.getItem('selectedTimerId');
          if (selectedTimerId) {
              headerTitle.textContent = 'Edit Timer';
              currentTimerId = selectedTimerId;
              const allTimers = loadTimers();
              const timerToLoad = allTimers.find(t => t.id === selectedTimerId);

              if (timerToLoad) {
                  timerNameInput.value = timerToLoad.name;
                  repeatInput.value = timerToLoad.repeat;
                  // Deep copy intervals to ensure modifications don't affect the loaded object directly
                  intervals = JSON.parse(JSON.stringify(timerToLoad.intervals)); 
              } else {
                  console.warn(`Timer with ID ${selectedTimerId} not found. Starting a new timer.`);
                  currentTimerId = null; // Reset to add new if not found
                  intervals = []; // Start with empty intervals for a new timer
              }
          } else {
              headerTitle.textContent = 'Add Timer';
              currentTimerId = null;
              intervals = []; // Start with empty intervals for a new timer
          }
          renderIntervalList();
      });
    </script>
  </body>
</html>